pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
    timeout(time: 30, unit: 'MINUTES')
  }

  environment {
    AWS_DEFAULT_REGION = "ca-central-1"
  }

  stages {

    stage('Sanity & Discover services') {
      steps {
        script {
          // Show what we have (never fail here)
          sh """
            echo "PWD=$(pwd)"
            echo "Scanning for Dockerfiles (non-fatal)â€¦"
            (find backend -maxdepth 2 -type f -name Dockerfile 2>/dev/null || true) | sed 's|^./||'
            if [ -f frontend/Dockerfile ]; then echo "frontend/Dockerfile"; fi
          """

          // Build list safely (no 'set -e' so missing files don't kill the stage)
          def discovered = []

          // Optional frontend
          def hasFrontend = sh(script: 'test -f frontend/Dockerfile && echo yes || echo no', returnStdout: true).trim() == 'yes'
          if (hasFrontend) { discovered << 'frontend' }

          // Backend services that contain a Dockerfile
          def back = sh(
            script: '''
              if [ -d backend ]; then
                find backend -mindepth 1 -maxdepth 1 -type d | while read d; do
                  [ -f "$d/Dockerfile" ] && basename "$d"
                done
              fi
            ''',
            returnStdout: true
          ).trim()
          if (back) {
            discovered.addAll(back.split("\\n").collect { it.trim() }.findAll { it })
          }

          if (discovered.isEmpty()) {
            error "No services found. Add Dockerfile(s) under frontend/ or backend/<service>/"
          }

          env.SERVICE_LIST = discovered.join(',')
          echo "Services to build (sequential): ${env.SERVICE_LIST}"
        }
      }
    }

    stage('Compute tag') {
      steps {
        script {
          env.IMAGE_TAG = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('AWS login (ECR)') {
      steps {
        retry(2) {
          sh """
            set -e
            ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
            echo "\$ACCOUNT_ID" > .account_id
            aws ecr get-login-password --region "${env.AWS_DEFAULT_REGION}" \
              | docker login --username AWS --password-stdin "\$ACCOUNT_ID.dkr.ecr.${env.AWS_DEFAULT_REGION}.amazonaws.com"
          """
        }
      }
    }

    stage('Build & Push (sequential)') {
      steps {
        script {
          // helpers
          def toRepo = { name ->
            // frontend -> frontend ; helloService -> hello-service ; profileService -> profile-service
            name.replaceAll(/([a-z])([A-Z])/, '$1-$2').replaceAll(/[_\\s]+/, '-').toLowerCase()
          }
          def contextFor = { name -> name == 'frontend' ? 'frontend' : "backend/${name}" }

          def services = env.SERVICE_LIST.split(',').collect { it.trim() }.findAll { it }
          services.each { svc ->
            stage("Service: ${svc}") {
              def repo = toRepo(svc)
              def ctx  = contextFor(svc)
              def df   = "${ctx}/Dockerfile"

              // Ensure Dockerfile exists with exact case
              sh """
                set -e
                if [ ! -f "${df}" ]; then
                  echo "ERROR: Missing ${df}. File must be named exactly 'Dockerfile'."
                  exit 1
                fi
              """

              // Ensure ECR repo exists
              sh """
                set -e
                aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1 || \
                aws ecr create-repository --repository-name "${repo}" \
                  --image-scanning-configuration scanOnPush=true \
                  --encryption-configuration encryptionType=AES256
              """

              // Build
              retry(2) {
                sh """
                  set -e
                  echo "Building ${repo}:${env.IMAGE_TAG} from ${df} (context: ${ctx})"
                  docker build -t "${repo}:${env.IMAGE_TAG}" -f "${df}" "${ctx}"
                """
              }

              // Tag & push
              retry(2) {
                sh """
                  set -e
                  ACCOUNT_ID=\$(cat .account_id)
                  REG="\${ACCOUNT_ID}.dkr.ecr.${env.AWS_DEFAULT_REGION}.amazonaws.com"
                  docker tag "${repo}:${env.IMAGE_TAG}" "\${REG}/${repo}:${env.IMAGE_TAG}"
                  docker tag "${repo}:${env.IMAGE_TAG}" "\${REG}/${repo}:latest"
                  docker push "\${REG}/${repo}:${env.IMAGE_TAG}"
                  docker push "\${REG}/${repo}:latest"
                """
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      sh 'docker image prune -f || true'
      sh 'rm -f .account_id || true'
    }
  }
}
