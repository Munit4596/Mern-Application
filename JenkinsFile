pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
    timeout(time: 30, unit: 'MINUTES')
  }

  environment {
    AWS_DEFAULT_REGION = "ca-central-1"
  }

  stages {

    stage('Sanity & Discover services') {
      steps {
        script {
          // Show what we have (never fail here)
          sh '''
            echo "PWD=$(pwd)"
            echo "Scanning for Dockerfiles (non-fatal)â€¦"
            (find backend -maxdepth 2 -type f -name Dockerfile 2>/dev/null || true) | sed 's|^./||'
            if [ -f frontend/Dockerfile ]; then echo "frontend/Dockerfile"; fi
          '''

          // Build up list without using 'set -e' so missing files don't kill the stage
          def discovered = []

          // frontend (optional)
          def hasFrontend = sh(script: '[ -f frontend/Dockerfile ] && echo yes || echo no', returnStdout: true).trim() == 'yes'
          if (hasFrontend) discovered << 'frontend'

          // backend services (required at least one)
          def back = sh(
            script: '''
              if [ -d backend ]; then
                find backend -mindepth 1 -maxdepth 1 -type d | while read d; do
                  [ -f "$d/Dockerfile" ] && basename "$d"
                done
              fi
            ''',
            returnStdout: true
          ).trim()

          if (back) {
            discovered.addAll(back.split("\\n").collect { it.trim() }.findAll { it })
          }

          if (discovered.isEmpty()) {
            error "No services found. Add Dockerfile(s) under frontend/ or backend/<service>/"
          }

          env.SERVICE_LIST = discovered.join(',')
          echo "Services to build (sequential): ${env.SERVICE_LIST}"
        }
      }
    }

    stage('Compute tag') {
      steps {
        script {
          env.IMAGE_TAG = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('AWS login (ECR)') {
      steps {
        retry(2) {
          sh '''
            set -e
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            echo "$ACCOUNT_ID" > .account_id
            aws ecr get-login-password --region "$AWS_DEFAULT_REGION" \
              | docker login --username AWS --password-stdin "${ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
          '''
        }
      }
    }

    stage('Build & Push (sequential)') {
      steps {
        script {
          def toRepo = { name ->
            // frontend -> frontend ; helloService -> hello-service ; profileService -> profile-service
            name.replaceAll(/([a-z])([A-Z])/, '$1-$2').replaceAll(/[_\\s]+/, '-').toLowerCase()
          }
          def contextFor = { name -> name == 'frontend' ? 'frontend' : "backend/${name}" }

          def services = env.SERVICE_LIST.split(',').collect { it.trim() }.findAll { it }
          services.each { svc ->
            stage("Service: ${svc}") {
              def repo = toRepo(svc)
              def ctx  = contextFor(svc)
              def df   = "${ctx}/Dockerfile"

              // Ensure Dockerfile exists with exact case
              sh """
                set -e
                if [ ! -f "${df}" ]; then
                  echo "ERROR: Missing ${df}. File must be named exactly 'Dockerfile'."
                  exit 1
                fi
              """
