pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
    timeout(time: 30, unit: 'MINUTES')
  }

  environment {
    AWS_DEFAULT_REGION = 'ca-central-1'
  }

  stages {

    stage('Sanity & Discover services') {
      steps {
        script {
          // Non-fatal scan
          sh '''
            echo "PWD=$(pwd)"
            echo "Scanning for Dockerfilesâ€¦"
            (find backend -maxdepth 2 -type f -name Dockerfile 2>/dev/null || true) | sed "s|^./||"
            if [ -f frontend/Dockerfile ]; then echo "frontend/Dockerfile"; fi
          '''

          // Build a list of services safely
          def discovered = []

          // Optional frontend
          def hasFrontend = sh(script: 'test -f frontend/Dockerfile && echo yes || echo no', returnStdout: true).trim() == 'yes'
          if (hasFrontend) discovered << 'frontend'

          // Backend/<service>/Dockerfile
          def back = sh(
            script: '''
              if [ -d backend ]; then
                find backend -mindepth 1 -maxdepth 1 -type d | while read d; do
                  [ -f "$d/Dockerfile" ] && basename "$d"
                done
              fi
            ''',
            returnStdout: true
          ).trim()

          if (back) {
            discovered.addAll(back.split("\\n").collect { it.trim() }.findAll { it })
          }

          if (discovered.isEmpty()) {
            error 'No services found. Add Dockerfile(s) under frontend/ or backend/<service>/'
          }

          env.SERVICE_LIST = discovered.join(',')
          echo "Services to build (sequential): ${env.SERVICE_LIST}"
        }
      }
    }

    stage('Compute tag') {
      steps {
        script {
          env.IMAGE_TAG = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('AWS login (ECR)') {
      steps {
        retry(2) {
          sh '''
            set -e
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            echo "$ACCOUNT_ID" > .account_id
            aws ecr get-login-password --region "$AWS_DEFAULT_REGION" \
              | docker login --username AWS --password-stdin "$ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"
          '''
        }
      }
    }

    stage('Build & Push (sequential)') {
      steps {
        script {
          // helpers (Groovy)
          def toRepo = { name ->
            // frontend -> frontend ; helloService -> hello-service ; profileService -> profile-service
            name.replaceAll(/([a-z])([A-Z])/, '$1-$2').replaceAll(/[_\\s]+/, '-').toLowerCase()
          }
          def contextFor = { name -> name == 'frontend' ? 'frontend' : "backend/${name}" }

          def services = env.SERVICE_LIST.split(',').collect { it.trim() }.findAll { it }
          services.each { svc ->
            stage("Service: ${svc}") {
              def repo = toRepo(svc)
              def ctx  = contextFor(svc)
              def df   = "${ctx}/Dockerfile"

              // Pass Groovy vars to sh via environment to avoid ${} in the shell script
              withEnv(["REPO=${repo}", "CTX=${ctx}", "DF=${df}"]) {

                // Ensure Dockerfile exists (exact case)
                sh '''
                  set -e
                  if [ ! -f "$DF" ]; then
                    echo "ERROR: Missing $DF (must be exactly 'Dockerfile')."
                    exit 1
                  fi
                '''

                // Ensure ECR repo exists
                sh '''
                  set -e
                  aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1 || \
                  aws ecr create-repository --repository-name "$REPO" \
                    --image-scanning-configuration scanOnPush=true \
                    --encryption-configuration encryptionType=AES256
                '''

                // Build
                retry(2) {
                  sh '''
                    set -e
                    echo "Building $REPO:$IMAGE_TAG from $DF (context: $CTX)"
                    docker build -t "$REPO:$IMAGE_TAG" -f "$DF" "$CTX"
                  '''
                }

                // Tag & push
                retry(2) {
                  sh '''
                    set -e
                    ACCOUNT_ID=$(cat .account_id)
                    REG="$ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"
                    docker tag "$REPO:$IMAGE_TAG" "$REG/$REPO:$IMAGE_TAG"
                    docker tag "$REPO:$IMAGE_TAG" "$REG/$REPO:latest"
                    docker push "$REG/$REPO:$IMAGE_TAG"
                    docker push "$REG/$REPO:latest"
                  '''
                }
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      sh 'docker image prune -f || true'
      sh 'rm -f .account_id || true'
    }
  }
}
